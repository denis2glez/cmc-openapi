/*
 * CoinMarketCap Get aggregate market metrics (latest)
 *
 * Get the latest quote of aggregate market metrics. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  **This endpoint is available on the following API plans:** - Starter - Hobbyist - Standard - Professional - Enterprise  **Cache / Update frequency:** Every ~5 minutes. This endpoint will be migrated to ~1 minute updates shortly.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method `get_v1_cryptocurrency_ohlcv_historical`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1CryptocurrencyOhlcvHistoricalError {
    UnknownValue(serde_json::Value),
}

/// Return an interval of historic OHLCV (Open, High, Low, Close, Volume) market quotes for a cryptocurrency.  **Technical Details** One OHLCV quote will be returned for every \"time_period\" between your \"time_start\" and \"time_end\". If a \"time_start\" is not supplied, the \"time_period\" will be applied in reverse from \"time_end\". If \"time_end\" is not supplied, it defaults to the current time. If you don't need every \"time_period\" between your dates you may adjust the frequency that \"time_period\" is sampled using the \"interval\" parameter. For example with \"time_period\" set to \"daily\" you may set \"interval\" to \"2d\" to get the daily OHLCV for every other day. You could set \"interval\" to \"monthly\" to get the first daily OHLCV for each month, or set it to \"yearly\" to get the daily OHLCV value against the same date every year.  **Interval Options** There are 2 types of time interval formats that may be used for \"time_period\" and \"interval\" parameters. For \"time_period\" these return aggregate OHLCV data from the beginning to end of each interval period. Apply these time intervals to \"interval\" to adjust how frequently \"time_period\" is sampled.  The first are calendar year and time constants in UTC time: **\"daily\"** - Calendar day intervals for each UTC day. **\"weekly\"** - Calendar week intervals for each calendar week. **\"monthly\"** - Calendar month intervals for each calendar month. **\"yearly\"** - Calendar year intervals for each calendar year.  The second format is relative time: **\"d\"**: Time periods that repeat every \"d\" days (86400 second intervals). Supported day intervals are: \"1d\", \"2d\", \"3d\", \"7d\", \"14d\", \"15d\", \"30d\", \"60d\", \"90d\", \"365d\".  **Note:** \"time_period\" currently only supports the \"daily\" option. \"interval\" supports all interval options.  **This endpoint is available on the following API plans:** - ~~Starter~~ - ~~Hobbyist~~ - Standard (1 month) - Professional (12 months) - Enterprise (Up to 5 years)  **Cache / Update frequency:** Every 24 hours for 1 day OHLCV ranges. Additional OHLCV ranges will be available in the near-term.
pub async fn get_v1_cryptocurrency_ohlcv_historical(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    count: Option<serde_json::Value>,
    id: Option<serde_json::Value>,
    interval: Option<serde_json::Value>,
    symbol: Option<serde_json::Value>,
    time_end: Option<serde_json::Value>,
    time_period: Option<serde_json::Value>,
    time_start: Option<serde_json::Value>,
) -> Result<(), Error<GetV1CryptocurrencyOhlcvHistoricalError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/cryptocurrency/ohlcv/historical",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = count {
        local_var_req_builder =
            local_var_req_builder.query(&[("count", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = interval {
        local_var_req_builder =
            local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = symbol {
        local_var_req_builder =
            local_var_req_builder.query(&[("symbol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_end {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_end", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_period {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_period", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_start {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1CryptocurrencyOhlcvHistoricalError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
