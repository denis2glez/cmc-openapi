/*
 * CoinMarketCap Get aggregate market metrics (latest)
 *
 * Get the latest quote of aggregate market metrics. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  **This endpoint is available on the following API plans:** - Starter - Hobbyist - Standard - Professional - Enterprise  **Cache / Update frequency:** Every ~5 minutes. This endpoint will be migrated to ~1 minute updates shortly.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use reqwest;

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method `get_v1_cryptocurrency_info`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1CryptocurrencyInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_cryptocurrency_listings_historical`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1CryptocurrencyListingsHistoricalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_cryptocurrency_listings_latest`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1CryptocurrencyListingsLatestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_cryptocurrency_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1CryptocurrencyMapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_cryptocurrency_marketpairs_latest`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1CryptocurrencyMarketpairsLatestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_cryptocurrency_ohlcv_historical`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1CryptocurrencyOhlcvHistoricalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_cryptocurrency_quotes_historical`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1CryptocurrencyQuotesHistoricalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_cryptocurrency_quotes_latest`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1CryptocurrencyQuotesLatestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_exchange_info`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1ExchangeInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_exchange_listings_historical`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1ExchangeListingsHistoricalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_exchange_listings_latest`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1ExchangeListingsLatestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_exchange_map`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1ExchangeMapError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_exchange_marketpairs_latest`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1ExchangeMarketpairsLatestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_exchange_quotes_historical`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1ExchangeQuotesHistoricalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_exchange_quotes_latest`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1ExchangeQuotesLatestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_globalmetrics_quotes_historical`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1GlobalmetricsQuotesHistoricalError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_globalmetrics_quotes_latest`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1GlobalmetricsQuotesLatestError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `get_v1_tools_priceconversion`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetV1ToolsPriceconversionError {
    UnknownValue(serde_json::Value),
}

/// Returns all static metadata for one or more cryptocurrencies including name, symbol, logo, and its various registered URLs.  **This endpoint is available on the following API plans:** - Starter - Hobbyist - Standard - Professional - Enterprise  **Cache / Update frequency:** Static data is updated only as needed, every 30 seconds.
pub async fn get_v1_cryptocurrency_info(
    configuration: &configuration::Configuration,
    id: Option<serde_json::Value>,
    symbol: Option<serde_json::Value>,
) -> Result<(), Error<GetV1CryptocurrencyInfoError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/cryptocurrency/info", configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = symbol {
        local_var_req_builder =
            local_var_req_builder.query(&[("symbol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1CryptocurrencyInfoError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint is not yet available. It is slated for release in Q3 2018.**   Get a paginated list of all cryptocurrencies with market data for a given historical time. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.
pub async fn get_v1_cryptocurrency_listings_historical(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    cryptocurrency_type: Option<serde_json::Value>,
    limit: Option<serde_json::Value>,
    sort: Option<serde_json::Value>,
    sort_dir: Option<serde_json::Value>,
    start: Option<serde_json::Value>,
    timestamp: Option<serde_json::Value>,
) -> Result<(), Error<GetV1CryptocurrencyListingsHistoricalError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/cryptocurrency/listings/historical",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cryptocurrency_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("cryptocurrency_type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_dir {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort_dir", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = timestamp {
        local_var_req_builder =
            local_var_req_builder.query(&[("timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1CryptocurrencyListingsHistoricalError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a paginated list of all cryptocurrencies with latest market data. You can configure this call to sort by market cap or another market ranking field. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.      Cryptocurrencies are listed by CoinMarketCap Rank by default. You may optionally sort against any of the following: **name**: The cryptocurrency name. **symbol**: The cryptocurrency symbol. **date_added**: Date cryptocurrency was added to the system. **market_cap**: market cap (latest trade price x circulating supply). **price**: latest average trade price across markets. **circulating_supply**: approximate number of coins currently in circulation. **total_supply**: approximate total amount of coins in existence right now (minus any coins that have been verifiably burned). **max_supply**: our best approximation of the maximum amount of coins that will ever exist in the lifetime of the currency. **num_market_pairs**: number of market pairs across all exchanges trading each currency. **volume_24h**: 24 hour trading volume for each currency. **percent_change_1h**: 1 hour trading price percentage change for each currency. **percent_change_24h**: 24 hour trading price percentage change for each currency. **percent_change_7d**: 7 day trading price percentage change for each currency.    **This endpoint is available on the following API plans:**   - Starter   - Hobbyist   - Standard   - Professional   - Enterprise  **Cache / Update frequency:** Every ~1 minute.     *NOTE: Use this endpoint if you need a sorted and paginated list of cryptocurrencies. If you want to query for market data on a few specific cryptocurrencies use /v1/cryptocurrency/quotes/latest which is optimized for that purpose. The response data between these endpoints is otherwise the same.*
pub async fn get_v1_cryptocurrency_listings_latest(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    cryptocurrency_type: Option<serde_json::Value>,
    limit: Option<serde_json::Value>,
    sort: Option<serde_json::Value>,
    sort_dir: Option<serde_json::Value>,
    start: Option<serde_json::Value>,
) -> Result<(), Error<GetV1CryptocurrencyListingsLatestError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/cryptocurrency/listings/latest",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = cryptocurrency_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("cryptocurrency_type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_dir {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort_dir", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1CryptocurrencyListingsLatestError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a paginated list of all cryptocurrencies by CoinMarketCap ID. We recommend using this convenience endpoint to lookup and utilize our unique cryptocurrency `id` across all endpoints as typical identifiers like ticker symbols can match multiple cryptocurrencies and change over time. As a convenience you may pass a comma-separated list of cryptocurrency symbols as `symbol` to filter this list to only those you require.     **This endpoint is available on the following API plans:**   - Starter   - Hobbyist   - Standard   - Professional   - Enterprise  **Cache / Update frequency:** Mapping data is updated only as needed, every 30 seconds.
pub async fn get_v1_cryptocurrency_map(
    configuration: &configuration::Configuration,
    limit: Option<serde_json::Value>,
    listing_status: Option<serde_json::Value>,
    start: Option<serde_json::Value>,
    symbol: Option<serde_json::Value>,
) -> Result<(), Error<GetV1CryptocurrencyMapError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/cryptocurrency/map", configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = listing_status {
        local_var_req_builder =
            local_var_req_builder.query(&[("listing_status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = symbol {
        local_var_req_builder =
            local_var_req_builder.query(&[("symbol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1CryptocurrencyMapError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists all market pairs for the specified cryptocurrency with associated stats. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.     **This endpoint is available on the following API plans:**   - ~~Starter~~   - ~~Hobbyist~~   - Standard   - Professional   - Enterprise  **Cache / Update frequency:** Every ~1 minute.
pub async fn get_v1_cryptocurrency_marketpairs_latest(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    id: Option<serde_json::Value>,
    limit: Option<serde_json::Value>,
    start: Option<serde_json::Value>,
    symbol: Option<serde_json::Value>,
) -> Result<(), Error<GetV1CryptocurrencyMarketpairsLatestError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/cryptocurrency/market-pairs/latest",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = symbol {
        local_var_req_builder =
            local_var_req_builder.query(&[("symbol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1CryptocurrencyMarketpairsLatestError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Return an interval of historic OHLCV (Open, High, Low, Close, Volume) market quotes for a cryptocurrency.  **Technical Details** One OHLCV quote will be returned for every \"time_period\" between your \"time_start\" and \"time_end\". If a \"time_start\" is not supplied, the \"time_period\" will be applied in reverse from \"time_end\". If \"time_end\" is not supplied, it defaults to the current time. If you don't need every \"time_period\" between your dates you may adjust the frequency that \"time_period\" is sampled using the \"interval\" parameter. For example with \"time_period\" set to \"daily\" you may set \"interval\" to \"2d\" to get the daily OHLCV for every other day. You could set \"interval\" to \"monthly\" to get the first daily OHLCV for each month, or set it to \"yearly\" to get the daily OHLCV value against the same date every year.  **Interval Options** There are 2 types of time interval formats that may be used for \"time_period\" and \"interval\" parameters. For \"time_period\" these return aggregate OHLCV data from the beginning to end of each interval period. Apply these time intervals to \"interval\" to adjust how frequently \"time_period\" is sampled.  The first are calendar year and time constants in UTC time: **\"daily\"** - Calendar day intervals for each UTC day. **\"weekly\"** - Calendar week intervals for each calendar week. **\"monthly\"** - Calendar month intervals for each calendar month. **\"yearly\"** - Calendar year intervals for each calendar year.  The second format is relative time: **\"d\"**: Time periods that repeat every \"d\" days (86400 second intervals). Supported day intervals are: \"1d\", \"2d\", \"3d\", \"7d\", \"14d\", \"15d\", \"30d\", \"60d\", \"90d\", \"365d\".  **Note:** \"time_period\" currently only supports the \"daily\" option. \"interval\" supports all interval options.  **This endpoint is available on the following API plans:** - ~~Starter~~ - ~~Hobbyist~~ - Standard (1 month) - Professional (12 months) - Enterprise (Up to 5 years)  **Cache / Update frequency:** Every 24 hours for 1 day OHLCV ranges. Additional OHLCV ranges will be available in the near-term.
pub async fn get_v1_cryptocurrency_ohlcv_historical(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    count: Option<serde_json::Value>,
    id: Option<serde_json::Value>,
    interval: Option<serde_json::Value>,
    symbol: Option<serde_json::Value>,
    time_end: Option<serde_json::Value>,
    time_period: Option<serde_json::Value>,
    time_start: Option<serde_json::Value>,
) -> Result<(), Error<GetV1CryptocurrencyOhlcvHistoricalError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/cryptocurrency/ohlcv/historical",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = count {
        local_var_req_builder =
            local_var_req_builder.query(&[("count", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = interval {
        local_var_req_builder =
            local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = symbol {
        local_var_req_builder =
            local_var_req_builder.query(&[("symbol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_end {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_end", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_period {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_period", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_start {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1CryptocurrencyOhlcvHistoricalError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns an interval of historic market quotes for any cryptocurrency based on time and interval parameters.  **Technical Details** A historic quote for every \"interval\" period between your \"time_start\" and \"time_end\" will be returned. If a \"time_start\" is not supplied, the \"interval\" will be applied in reverse from \"time_end\". If \"time_end\" is not supplied, it defaults to the current time. At each \"interval\" period, the historic quote that is closest in time to the requested time will be returned. If no historic quotes are available in a given \"interval\" period up until the next interval period, it will be skipped.  **Interval Options** There are 2 types of time interval formats that may be used for \"interval\".  The first are calendar year and time constants in UTC time: **\"hourly\"** - Get the first quote available at the beginning of each calendar hour. **\"daily\"** - Get the first quote available at the beginning of each calendar day. **\"weekly\"** - Get the first quote available at the beginning of each calendar week. **\"monthly\"** - Get the first quote available at the beginning of each calendar month. **\"yearly\"** - Get the first quote available at the beginning of each calendar year.  The second are relative time intervals. **\"m\"**: Get the first quote available every \"m\" minutes (60 second intervals). Supported minutes are: \"5m\", \"10m\", \"15m\", \"30m\", \"45m\". **\"h\"**: Get the first quote available every \"h\" hours (3600 second intervals). Supported hour intervals are: \"1h\", \"2h\", \"3h\", \"6h\", \"12h\". **\"d\"**: Get the first quote available every \"d\" days (86400 second intervals). Supported day intervals are: \"1d\", \"2d\", \"3d\", \"7d\", \"14d\", \"15d\", \"30d\", \"60d\", \"90d\", \"365d\".  **This endpoint is available on the following API plans:** - ~~Starter~~ - ~~Hobbyist~~ - Standard (1 month) - Professional (12 months) - Enterprise (Up to 5 years)  **Cache / Update frequency:** Every ~5 minutes. This endpoint will be migrated to ~1 minute updates shortly.
pub async fn get_v1_cryptocurrency_quotes_historical(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    count: Option<serde_json::Value>,
    id: Option<serde_json::Value>,
    interval: Option<serde_json::Value>,
    symbol: Option<serde_json::Value>,
    time_end: Option<serde_json::Value>,
    time_start: Option<serde_json::Value>,
) -> Result<(), Error<GetV1CryptocurrencyQuotesHistoricalError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/cryptocurrency/quotes/historical",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = count {
        local_var_req_builder =
            local_var_req_builder.query(&[("count", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = interval {
        local_var_req_builder =
            local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = symbol {
        local_var_req_builder =
            local_var_req_builder.query(&[("symbol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_end {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_end", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_start {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1CryptocurrencyQuotesHistoricalError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the latest market quote for 1 or more cryptocurrencies. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  **This endpoint is available on the following API plans:** - Starter - Hobbyist - Standard - Professional - Enterprise  **Cache / Update frequency:** Every ~1 minute.
pub async fn get_v1_cryptocurrency_quotes_latest(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    id: Option<serde_json::Value>,
    symbol: Option<serde_json::Value>,
) -> Result<(), Error<GetV1CryptocurrencyQuotesLatestError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/cryptocurrency/quotes/latest",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = symbol {
        local_var_req_builder =
            local_var_req_builder.query(&[("symbol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1CryptocurrencyQuotesLatestError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns all static metadata for one or more exchanges including logo and homepage URL.    **This endpoint is available on the following API plans:**   - ~~Starter~~   - Hobbyist   - Standard   - Professional   - Enterprise  **Cache / Update frequency:** Static data is updated only as needed, every 30 seconds.
pub async fn get_v1_exchange_info(
    configuration: &configuration::Configuration,
    id: Option<serde_json::Value>,
    slug: Option<serde_json::Value>,
) -> Result<(), Error<GetV1ExchangeInfoError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/exchange/info", configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = slug {
        local_var_req_builder =
            local_var_req_builder.query(&[("slug", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1ExchangeInfoError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// **This endpoint is not yet available. It is slated for release in Q3 2018.**   Get a paginated list of all cryptocurrency exchanges with historical market data for a given point in time. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.
pub async fn get_v1_exchange_listings_historical(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    limit: Option<serde_json::Value>,
    market_type: Option<serde_json::Value>,
    sort: Option<serde_json::Value>,
    sort_dir: Option<serde_json::Value>,
    start: Option<serde_json::Value>,
    timestamp: Option<serde_json::Value>,
) -> Result<(), Error<GetV1ExchangeListingsHistoricalError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/exchange/listings/historical",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = market_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("market_type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_dir {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort_dir", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = timestamp {
        local_var_req_builder =
            local_var_req_builder.query(&[("timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1ExchangeListingsHistoricalError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a paginated list of all cryptocurrency exchanges with 24 hour volume. Additional market data fields will be available in the future. You can configure this call to sort by 24 hour volume or another field. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.      **This endpoint is available on the following API plans:**   - ~~Starter~~   - ~~Hobbyist~~   - Standard   - Professional   - Enterprise  **Cache / Update frequency:** Every ~5 minutes. This endpoint will be migrated to ~1 minute updates shortly.        *NOTE: Use this endpoint if you need a sorted and paginated list of exchanges. If you want to query for market data on a few specific exchanges use /v1/exchange/quotes/latest which is optimized for that purpose. The response data between these endpoints is otherwise the same.*
pub async fn get_v1_exchange_listings_latest(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    limit: Option<serde_json::Value>,
    market_type: Option<serde_json::Value>,
    sort: Option<serde_json::Value>,
    sort_dir: Option<serde_json::Value>,
    start: Option<serde_json::Value>,
) -> Result<(), Error<GetV1ExchangeListingsLatestError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/exchange/listings/latest", configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = market_type {
        local_var_req_builder =
            local_var_req_builder.query(&[("market_type", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = sort_dir {
        local_var_req_builder =
            local_var_req_builder.query(&[("sort_dir", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1ExchangeListingsLatestError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns a paginated list of all cryptocurrency exchanges by CoinMarketCap ID. We recommend using this convenience endpoint to lookup and utilize our unique exchange `id` across all endpoints as typical exchange identifiers may change over time. As a convenience you may pass a comma-separated list of exchanges by `slug` to filter this list to only those you require.  **This endpoint is available on the following API plans:**   - ~~Starter~~   - Hobbyist   - Standard   - Professional   - Enterprise  **Cache / Update frequency:** Mapping data is updated only as needed, every 30 seconds.
pub async fn get_v1_exchange_map(
    configuration: &configuration::Configuration,
    limit: Option<serde_json::Value>,
    listing_status: Option<serde_json::Value>,
    slug: Option<serde_json::Value>,
    start: Option<serde_json::Value>,
) -> Result<(), Error<GetV1ExchangeMapError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/exchange/map", configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = listing_status {
        local_var_req_builder =
            local_var_req_builder.query(&[("listing_status", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = slug {
        local_var_req_builder =
            local_var_req_builder.query(&[("slug", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1ExchangeMapError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get a list of active market pairs for an exchange. Active means the market pair is open for trading. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.'    **This endpoint is available on the following API plans:**   - ~~Starter~~   - ~~Hobbyist~~   - Standard   - Professional   - Enterprise  **Cache / Update frequency:** Every ~5 minutes. This endpoint will be migrated to ~1 minute updates shortly.
pub async fn get_v1_exchange_marketpairs_latest(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    id: Option<serde_json::Value>,
    limit: Option<serde_json::Value>,
    slug: Option<serde_json::Value>,
    start: Option<serde_json::Value>,
) -> Result<(), Error<GetV1ExchangeMarketpairsLatestError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/exchange/market-pairs/latest",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder =
            local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = slug {
        local_var_req_builder =
            local_var_req_builder.query(&[("slug", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder =
            local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1ExchangeMarketpairsLatestError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Returns an interval of historic quotes for any exchange based on time and interval parameters.  Historical exchange quotes currently include: volume_24: Combined 24 hour volume for all market pairs at each historical interval. num_market_pairs: Number of market pairs available at each historical interval. Quotes are returned in USD. Additional currency conversion options and additional fields will be available in the future.  **Technical Details** A historic quote for every \"interval\" period between your \"time_start\" and \"time_end\" will be returned. If a \"time_start\" is not supplied, the \"interval\" will be applied in reverse from \"time_end\". If \"time_end\" is not supplied, it defaults to the current time. At each \"interval\" period, the historic quote that is closest in time to the requested time will be returned. If no historic quotes are available in a given \"interval\" period up until the next interval period, it will be skipped.  **Interval Options** There are 2 types of time interval formats that may be used for \"interval\".  The first are calendar year and time constants in UTC time: **\"hourly\"** - Get the first quote available at the beginning of each calendar hour. **\"daily\"** - Get the first quote available at the beginning of each calendar day. **\"weekly\"** - Get the first quote available at the beginning of each calendar week. **\"monthly\"** - Get the first quote available at the beginning of each calendar month. **\"yearly\"** - Get the first quote available at the beginning of each calendar year.  The second are relative time intervals. **\"m\"**: Get the first quote available every \"m\" minutes (60 second intervals). Supported minutes are: \"5m\", \"10m\", \"15m\", \"30m\", \"45m\". **\"h\"**: Get the first quote available every \"h\" hours (3600 second intervals). Supported hour intervals are: \"1h\", \"2h\", \"3h\", \"6h\", \"12h\". **\"d\"**: Get the first quote available every \"d\" days (86400 second intervals). Supported day intervals are: \"1d\", \"2d\", \"3d\", \"7d\", \"14d\", \"15d\", \"30d\", \"60d\", \"90d\", \"365d\".  **This endpoint is available on the following API plans:**   - ~~Starter~~   - ~~Hobbyist~~   - Standard (1 month)   - Professional (12 months)   - Enterprise (Up to 5 years)  **Cache / Update frequency:** Every ~5 minutes. This endpoint will be migrated to ~1 minute updates shortly.
pub async fn get_v1_exchange_quotes_historical(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    count: Option<serde_json::Value>,
    id: Option<serde_json::Value>,
    interval: Option<serde_json::Value>,
    slug: Option<serde_json::Value>,
    time_end: Option<serde_json::Value>,
    time_start: Option<serde_json::Value>,
) -> Result<(), Error<GetV1ExchangeQuotesHistoricalError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/exchange/quotes/historical", configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = count {
        local_var_req_builder =
            local_var_req_builder.query(&[("count", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = interval {
        local_var_req_builder =
            local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = slug {
        local_var_req_builder =
            local_var_req_builder.query(&[("slug", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_end {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_end", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_start {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1ExchangeQuotesHistoricalError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the latest 24 hour volume quote for 1 or more exchanges. Additional market data fields will be available in the future. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  **This endpoint is available on the following API plans:** - ~~Starter~~ - ~~Hobbyist~~ - Standard - Professional - Enterprise  **Cache / Update frequency:** Every ~5 minutes. This endpoint will be migrated to ~1 minute updates shortly.
pub async fn get_v1_exchange_quotes_latest(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    id: Option<serde_json::Value>,
    slug: Option<serde_json::Value>,
) -> Result<(), Error<GetV1ExchangeQuotesLatestError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/exchange/quotes/latest", configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = slug {
        local_var_req_builder =
            local_var_req_builder.query(&[("slug", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1ExchangeQuotesLatestError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get an interval of aggregate 24 hour volume and market cap data globally based on time and interval parameters.  **Technical Details** A historic quote for every \"interval\" period between your \"time_start\" and \"time_end\" will be returned. If a \"time_start\" is not supplied, the \"interval\" will be applied in reverse from \"time_end\". If \"time_end\" is not supplied, it defaults to the current time. At each \"interval\" period, the historic quote that is closest in time to the requested time will be returned. If no historic quotes are available in a given \"interval\" period up until the next interval period, it will be skipped.  **Interval Options** There are 2 types of time interval formats that may be used for \"interval\".  The first are calendar year and time constants in UTC time: **\"hourly\"** - Get the first quote available at the beginning of each calendar hour. **\"daily\"** - Get the first quote available at the beginning of each calendar day. **\"weekly\"** - Get the first quote available at the beginning of each calendar week. **\"monthly\"** - Get the first quote available at the beginning of each calendar month. **\"yearly\"** - Get the first quote available at the beginning of each calendar year.  The second are relative time intervals. **\"m\"**: Get the first quote available every \"m\" minutes (60 second intervals). Supported minutes are: \"5m\", \"10m\", \"15m\", \"30m\", \"45m\". **\"h\"**: Get the first quote available every \"h\" hours (3600 second intervals). Supported hour intervals are: \"1h\", \"2h\", \"3h\", \"6h\", \"12h\". **\"d\"**: Get the first quote available every \"d\" days (86400 second intervals). Supported day intervals are: \"1d\", \"2d\", \"3d\", \"7d\", \"14d\", \"15d\", \"30d\", \"60d\", \"90d\", \"365d\".  **This endpoint is available on the following API plans:** - ~~Starter~~ - ~~Hobbyist~~ - Standard (1 month) - Professional (12 months) - Enterprise (Up to 5 years)  **Cache / Update frequency:** Every ~5 minutes. This endpoint will be migrated to ~1 minute updates shortly.
pub async fn get_v1_globalmetrics_quotes_historical(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
    count: Option<serde_json::Value>,
    interval: Option<serde_json::Value>,
    time_end: Option<serde_json::Value>,
    time_start: Option<serde_json::Value>,
) -> Result<(), Error<GetV1GlobalmetricsQuotesHistoricalError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/global-metrics/quotes/historical",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = count {
        local_var_req_builder =
            local_var_req_builder.query(&[("count", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = interval {
        local_var_req_builder =
            local_var_req_builder.query(&[("interval", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_end {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_end", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time_start {
        local_var_req_builder =
            local_var_req_builder.query(&[("time_start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1GlobalmetricsQuotesHistoricalError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Get the latest quote of aggregate market metrics. Use the \"convert\" option to return market values in multiple fiat and cryptocurrency conversions in the same call.  **This endpoint is available on the following API plans:** - Starter - Hobbyist - Standard - Professional - Enterprise  **Cache / Update frequency:** Every ~5 minutes. This endpoint will be migrated to ~1 minute updates shortly.
pub async fn get_v1_globalmetrics_quotes_latest(
    configuration: &configuration::Configuration,
    convert: Option<serde_json::Value>,
) -> Result<(), Error<GetV1GlobalmetricsQuotesLatestError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!(
        "{}/v1/global-metrics/quotes/latest",
        configuration.base_path
    );
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1GlobalmetricsQuotesLatestError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Convert an amount of one currency into up to 32 other cryptocurrency or fiat currencies at the same time using latest exchange rates. Optionally pass a historical timestamp to convert values based on historic averages.  **Note:** Historical fiat conversions aren't yet available and the latest fiat rates will be used as noted by the `last_updated` timestamp included in the market quote. Historical fiat rates will be coming soon.  **This endpoint is available on the following API plans:** - ~~Starter~~ - Hobbyist - Standard - Professional - Enterprise  **Cache / Update frequency:** Every ~5 minutes. This endpoint will be migrated to ~1 minute updates shortly.
pub async fn get_v1_tools_priceconversion(
    configuration: &configuration::Configuration,
    amount: Option<serde_json::Value>,
    convert: Option<serde_json::Value>,
    id: Option<serde_json::Value>,
    symbol: Option<serde_json::Value>,
    time: Option<serde_json::Value>,
) -> Result<(), Error<GetV1ToolsPriceconversionError>> {
    let local_var_client = &configuration.client;

    let local_var_uri_str = format!("{}/v1/tools/price-conversion", configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = amount {
        local_var_req_builder =
            local_var_req_builder.query(&[("amount", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = convert {
        local_var_req_builder =
            local_var_req_builder.query(&[("convert", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = id {
        local_var_req_builder = local_var_req_builder.query(&[("id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = symbol {
        local_var_req_builder =
            local_var_req_builder.query(&[("symbol", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = time {
        local_var_req_builder =
            local_var_req_builder.query(&[("time", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<GetV1ToolsPriceconversionError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status: local_var_status,
            content: local_var_content,
            entity: local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
